//********************************************************************************
//*
//*		T98 Interface for 9865 I/O Adapter
//*
//*	2013 Jul   :	V1
//*	2013 Jul 12:	V2 updated for nEXCP bit added to adapter
//*	2013 Jul 13:	V3 updated CTL, EXEC, AUTOR
//*	2013 Nov:	split from command program
//*	2014 Mar:	converted to C
//*
//********************************************************************************
#include <sys/types.h>
#include <stdio.h>
#include <time.h>
#include "../util/util.h"
#include "../util/attn.h"
#ifdef __linux__
	#include <wiringPi.h>
#else
	#include "../util/gpioDummy.h"
#endif
#include "t98.h"


//----------------------------------------------
// wiringPi pin numbers
// Note these are different than both the header pin numbers and the BCM GPIO numbers

#define PIN_SDI			13						// header pin 21; MISO
#define PIN_SDO			12						// header pin 19; MOSI
#define PIN_SCP			14						// header pin 23; SCLK
#define PIN_CTL			3						// header pin 15; GPIO3


//-----------------------------------------------
// drive commands and status

#define	AOR_EXEC		0x8000						// AOR execute bit
#define AOR_AUTOR		0x4000						// AOR auto-respond bit

#define STAT_NOWRITE		0x000400					// writing not permitted
#define STAT_DORN		0x000800					// data overrun
#define STAT_NOCASS		0x001000					// no cassette in drive
#define STAT_LDR		0x002000					// clear leader (BOT/EOT)
#define STAT_DRDY		0x004000					// data ready
#define STAT_EXCP		0x008000					// exception, negative true from adapter
										// the following stats are generated by the interface code, not by the hardware
#define STAT_BUFFULL		0x010000					// buffer filled
#define STAT_INTR		0x020000					// failed/interrupted operation
#define STAT_TIMEOUTCLR		0x040000					// timeout waiting to clear leader
#define STAT_TIMEOUTDRDY	0x080000					// timeout waiting for DRDY (generated by controller, not by drive)


//-----------------------------------------------
// Transfer command and write-byte (send) to adapter, and status and read-byte (recv) to controller, all in one go.
// Note the status returned is from before the actual execute (+edge of CTL) if execute was directed (EXEC=1).

int
T98__Transfer( self, send )
	T98*			self;
	int			send;
 {
	int			recv, i, j;

	digitalWrite( PIN_CTL, 0 );						// latch AIR

	recv = 0;

	for( i=0; i<16; ++i )							// 16 bits in and out
	 {	digitalWrite( PIN_SDO, send & 1 );				// send bit
		send = send >> 1;
		recv = (recv<<1) | (digitalRead(PIN_SDI)&1);			// receive bit

		digitalWrite( PIN_SCP, 0 );					// clock pulse
		for( j=50; j; --j );						// a little delay
		digitalWrite( PIN_SCP, 1 );
		for( j=50; j; --j );
	 }

	digitalWrite( PIN_CTL, 1 );						// reopen AIR

	return( recv ^ STAT_EXCP );						// invert exception bit to +true
 }


//-----------------------------------------------
// Simple polling-loop approach to waiting for exception/DRDY

static int
T98__WaitForException( self, timeout )
	T98*			self;
	int			timeout;
 {
	clock_t			endTm;

	endTm = clock() + timeout*CLOCKS_PER_SEC;				// calculate future timeout time

	while( digitalRead(PIN_SDI) != 0 )					// polling loop, wait for EXCP, hopefully DRDY
	 {	if( clock() > endTm )						// check for timeout
			return( STAT_TIMEOUTDRDY );
		if( Attn )
			return( STAT_INTR );
	 }

	return( 0 );
 }


//* END Private
//********************************************************************************
//* Public

//-----------------------------------------------
// Initialise adapter

T98*
T98_Open()
 {
	wiringPiSetup();							// initialize GPIO library

	pinMode( PIN_SDI, INPUT );						// initialize adapter
	pullUpDnControl( PIN_SDI, PUD_UP);
	//pullUpDnControl( PIN_SDI, PUD_OFF);

	pinMode( PIN_SDO, OUTPUT );
	pinMode( PIN_SCP, OUTPUT );
	pinMode( PIN_CTL, OUTPUT );

	digitalWrite( PIN_SDO, 0 );
	digitalWrite( PIN_SCP, 1 );
	digitalWrite( PIN_CTL, 0 );

	T98_Cmd( NULL, T98_CMD_STOP );					// execute an initial 'STOP' COMMAND

	return( NULL );
 }


//-----------------------------------------------
// Close adapter

void
T98_Close( self )
	T98*			self;
 {
 }


//-----------------------------------------------
// Execute the specified tape drive command.
// Note the status returned is from before the actual execute.

int
T98_Cmd( self, cw )
	T98*			self;
	int			cw;
 {
	return( T98__Transfer(self,cw|AOR_EXEC) );
 }


//-----------------------------------------------
// Read up to <maxBytes> into a buffer. Reading terminates when an exception status is indicated from the drive
// or when no data has been received for <timeout> seconds.
// The buffer is returned, with it's length adjusted to the number of bytes read.

int
T98_Read( self, rdCmd, bf, timeout )
	T98*			self;
	int			rdCmd;
	BF*			bf;
	int			timeout;
{
	clock_t			endTm;
	int			stat, sr;

	sr = T98_Cmd( self, rdCmd );					// start drive reading, this clears DRDY flag
	stat = sr & STAT_NOCASS;
	if( stat != 0 )
		goto fin;

	endTm = clock() + 5*CLOCKS_PER_SEC;					// before looking for data ensure EXCP has cleared,
	while( digitalRead(PIN_SDI) == 0 )					// usually this is waiting to get past leader
		if( clock() > endTm )						// check for timeout
		 {	stat = STAT_TIMEOUTCLR;
			goto fin;
		 }

	bf->l = 0;								// start with empty buffer
	repeat									// byte loop
	 {	sr = T98__Transfer( self, T98_CMD_CONT|AOR_AUTOR );		// get status and byte, ack DRDY
		stat = sr & (STAT_NOCASS|STAT_LDR|STAT_DORN);
		if( stat != 0 )							// exit byte loop if not OK
			goto fin;

		if( sr & STAT_DRDY )
		 {	if( bf->l == bf->size )					// check for room in buffer
			 {	stat = STAT_BUFFULL;
				break;
			 }
			bf_append( bf, sr & 0xFF );				// save byte
		 }
		stat = T98__WaitForException( self, timeout );			// wait for byte read
		if( stat != 0 )
			break;
	 }

 fin:	T98_Cmd( self, T98_CMD_STOP );						// stop drive

	return( stat );
 }


//-----------------------------------------------
// Write <buf> to tape
// The drive will start writing formed bytes as soon as the WFN command is executed.
// If in leader we must ignore the writing of (zero) bytes until leader has cleared, before writing data bytes.

int
T98_Write( self, bf )
	T98*			self;
	BF*			bf;
 {
	clock_t			endTm;
	int			stat, sr, i;

	endTm = clock() + 5*CLOCKS_PER_SEC;					// calculate future timeout time

	i = T98_CMD_WFN | AOR_EXEC;						// start drive writing, this clears DRDY flag
	repeat									// loop till leader has cleared
	 {	sr = T98__Transfer( self, i );					
		stat = sr & (STAT_NOCASS|STAT_NOWRITE);
		if( stat != 0 )						// !!! check logic of this loop !!!
			goto fin;
		if( !(sr & STAT_LDR) )						// if clear of leader good, get out
			break;
		if( clock() > endTm )						// check for timeout
		 {	stat = STAT_TIMEOUTCLR;
			goto fin;
		 }
		i = T98_CMD_CONT;						// just get status & clear DRDY on next ops
	 }

	for( i=0; i<bf->l; ++i )						// byte loop
	 {	sr = T98__Transfer( self, T98_CMD_WFN|AOR_AUTOR | bf->p[i] );	// send byte, ack DRDY
		stat = sr & (STAT_NOCASS|STAT_LDR|STAT_DORN);
		if( stat != 0 )							// exit byte loop if not OK
			goto fin;

		stat = T98__WaitForException( self, 5 );
		if( stat != 0 )							// exit byte loop if not OK
			goto fin;
	 }

 fin:	T98_Cmd( self, T98_CMD_STOP );						// stop drive

	return( stat );
 }


//-----------------------------------------------
// Convert status to displayable string

void
T98_printStat( sr )
	int			sr;
 {
	printf( "  status/read = %05X", sr );

		// drive
	if( sr & STAT_LDR		) printf( " leader"			);
	if( sr & STAT_NOCASS 		) printf( " noCassette"			);
	if( sr & STAT_NOWRITE		) printf( " noWrite"			);

		// 65 adapter
	if( sr & STAT_EXCP		) printf( " exception"			);
	if( sr & STAT_DRDY		) printf( " dataReady"			);
	if( sr & STAT_DORN		) printf( " dataOverRun"		);

		// code
	if( sr & STAT_BUFFULL		) printf( " bufferFull"			);
	if( sr & STAT_INTR		) printf( " interrupted"		);
	if( sr & STAT_TIMEOUTCLR	) printf( " timeout(noClearance)"	);
	if( sr & STAT_TIMEOUTDRDY	) printf( " timeout(noDRDY)"		);

	printf( "\n" );
 }


//-----------------------------------------------
// Hack for rewind command

int
T98_leader( sr )
	int			sr;
 {
	return( sr & STAT_LDR );
 }


//* EOF
//********************************************************************************
