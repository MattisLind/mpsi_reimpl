//********************************************************************************
//*
//*		T98 Interface to MPSI Relay
//*
//*	2014 Feb:	V1 Python - too slow for read
//*	2014 Feb:	V2 converted to C, 3-byte comm protocol, OK for read - too slow for write
//*	2014 Feb:	V3 protocol compressed to single exchange - still too slow for write
//*	2014 Feb:	V4 buffered write
//*
//********************************************************************************
#include <sys/types.h>
#include <stdio.h>
#include <time.h>
#include "../util/util.h"
#include "../mpsiServer/mpsi.h"
#include "t98.h"

#define BUFFER_MAXBYTES		6000						// not concise, but should be OK for an 8KW 9830, till we do something better


//-----------------------------------------------
// protocol directives for communicating with the relay program in the 9830

#define MTC_DIR_CMD		0x200
#define MTC_DIR_PUSHBYT		0x400
#define MTC_DIR_WRITE		0x800

#define MTC_C_WAIT		0x080						// command directive option bit to indicate the relay should not wait for the drive

#define MTC_W_CLRLDR		0x001						// write options
#define MTC_W_FBOF		0x002
#define MTC_W_WBOF		0x004


//-----------------------------------------------
// status codes

#define STAT_NOWRITE		0x000200					// writing not permitted
#define STAT_LDR		0x000400					// clear leader (BOT/EOT)
#define STAT_NOCASS		0x000800					// no cassette in drive
										// the following are generated by the code, not the hardware
#define STAT_BUFFULL		0x010000					// buffer filled
#define STAT_INTR		0x020000					// failed/interrupted operation
#define STAT_TIMEOUTCLR		0x040000					// timeout waiting to clear leader
#define STAT_ERRPROTOCOL	0x080000					// IO sequence error
#define STAT_SEGTOOLARGE	0x100000					// segment too large for writing

#define STAT_MASK		0xFF0F00


//-----------------------------------------------
// interface descriptor

typedef struct
 {	MPSI*			mpsi;
 }
				T98__;


//-----------------------------------------------
// Send a tape-command directive to the 9830.
// Return the tape status and read-byte.

static int
T98__Exec( self, dir )
	T98__*			self;
	int			dir;
 {
	int			sr;

	MPSI_Transfer( self->mpsi, dir | MPSI_OR_ACK );				// send directive to MPSI / 9830

	if( !MPSI_Wait(self->mpsi) )						// wait for 9830
		return( STAT_INTR );

	sr = MPSI_Transfer( self->mpsi, 0 );					// get reply
	if( (sr&MPSI_IR_DEVMASK)!=MPSI_IR_GENPURP || (~sr&MPSI_IR_INPUT)==0 )
		return( STAT_ERRPROTOCOL );

	sr = ~sr & 0xFFF;

	return( ((sr&0x100)<<3) | (sr&~STAT_NOCASS) );				// return status and read-byte, move NOCASS bit back into proper position
 }


#define T98__Cmd(self,tpCmd,to)		T98__Exec( self, MTC_DIR_CMD | ((tpCmd)>>8) )


//* END Private
//********************************************************************************
//* Public


//-----------------------------------------------
// Initialisation

T98*
T98_Open()
 {
	T98__*			self = r_alloc( T98__ );

	self->mpsi = MPSI_Open( -1 );						// use default clock width

	T98__Cmd( self, T98_CMD_STOP, 10 );					// execute an initial 'STOP' COMMAND

	return( (T98*)self );
 }


//-----------------------------------------------
// Termination

void
T98_Close( self )
	T98__*			self;
 {
	MPSI_Close( self->mpsi );

	r_free( self );
 }



//-----------------------------------------------
// Public access to Exec

int
T98_Cmd( self, cw )
	T98__*			self;
	int			cw;
 {
	return( T98__Cmd(self,cw,5) );
 }


//-----------------------------------------------
// Read bytes into the supplied buffer, up to a max of the size of the buffer (no automatic expansion).
// Reading terminates when an exception status occurs
// or when no data has been received for <timeout> seconds. !!! timeout not implemented !!!
// The status is returned, the length of the buffer is adjusted to the number of bytes read.

int
T98_Read( self, rdCmd, bf, timeout )
	T98__*			self;
	int			rdCmd;
	BF*			bf;
	int			timeout;
 {
	clock_t			endTm;
	int			stat, sr, oks;

	bf->l = 0;								// empty the buffer

	oks = 0;
	endTm = clock() + 5*CLOCKS_PER_SEC;					// allow a few seconds to get out of leader
	repeat
	 {	sr = T98__Cmd( self, rdCmd, 1 );				// start drive reading
		stat = sr & (STAT_MASK & ~STAT_NOWRITE);
		if( stat == STAT_LDR )						// if in leader reset ok counter
			oks = 0;
		else if( stat != 0 )						// if fatal get out
			goto fin;
		else if( ++oks >= 5 )						// should be tape by here, but confirm not a hiccup on opto sense (!!! this should be done with timers)
			break;

		if( clock() > endTm )						// check for timeout
		 {	stat = STAT_TIMEOUTCLR;
			goto fin;
		 }
	 }

	repeat									// byte loop
	 {	sr = T98__Exec( self, MTC_DIR_CMD | MTC_C_WAIT | (T98_CMD_CONT>>8) );	// wait for byte read
		stat = sr & (STAT_MASK & ~STAT_NOWRITE);
		if( stat != 0 )							// exit byte loop if not OK
			break;

		if( bf->l == bf->size )						// check for full buffer
		 {	stat = STAT_BUFFULL;
			break;
		 }
		bf_append( bf, sr & 0xFF );					// save byte
	 }

 fin:	T98__Cmd( self, T98_CMD_STOP, 1 );					// stop drive

	return( stat );
 }


//-----------------------------------------------
// Write the tape image in <bf> to tape
// The buffer is sent in segments to the 9830, each segment is written to tape before the next is sent.
// A segment is a span of the buffer in-between BOF control-bytes, or between BOT/BOF or BOF/EOT.
//
// There are some limitations on the image that can be written:
//  - Segments will always be an even number of bytes due to the Relay code and word packing in the 9830 buffer.
//  - There is some minimum length of a segment due to the BOF seek after backing up over the BOF.
//    This is probably why a minimum file length (10 IIRC) is specified by HP.

int
T98_Write( self, bf )
	T98__*			self;
	BF*			bf;
 {
	int			segmentStart, segmentEnd, segmentLen, subdirective, stat, i;

	segmentStart = 0;
	segmentEnd   = 0;

	i = 0;
	repeat
	 {	if( i<bf->l && bf->p[i++]<=0xFF )					// watch for end of buffer and BOF control bytes
		 {	++segmentEnd;							// within segment, include byte in segment
			continue;
		 }

		segmentLen = segmentEnd - segmentStart;					// segment boundaries found, proceed to push to 9830 and write

		if( segmentLen > BUFFER_MAXBYTES )					// check if segment will exceed 9830 memory
		 {	stat = STAT_SEGTOOLARGE;
			break;
		 }

		if( segmentLen%2 != 0 ) T98__Exec( self, MTC_DIR_PUSHBYT | 0 );		// if odd number of bytes in seg push a last zero byte to make even
		while( segmentEnd > segmentStart )					// send segment bytes in reverse order
			T98__Exec( self, MTC_DIR_PUSHBYT | bf->p[--segmentEnd] );

		subdirective = segmentStart==0 ? MTC_W_CLRLDR : MTC_W_FBOF;		// first segment must get clear of leader, subsequent segs must seek back to BOF
		if( i < bf->l ) subdirective |= MTC_W_WBOF;				// last segment does not write following BOF

		printf( "  segment:  start=0x%04X  len=%4d  sub-dir=0x%02X\n", segmentStart, segmentLen, subdirective );

		stat = T98__Exec( self, MTC_DIR_WRITE | subdirective );			// write the segment to tape
		if( stat != 0 )
			break;

		if( i >= bf->l )							// get out at last segment
			break;

		segmentStart = i;							// delineate next segment
		segmentEnd   = segmentStart;
	 }

	return( stat );
 }


//-----------------------------------------------
// Print status

void
T98_printStat( sr )
	int			sr;
 {
	printf( "  status/read = %05X", sr );

	if( sr & STAT_LDR		) printf( " leader"			);
	if( sr & STAT_NOCASS 		) printf( " noCassette"			);
	if( sr & STAT_NOWRITE		) printf( " noWrite"			);

	if( sr & STAT_BUFFULL		) printf( " bufferFull"			);
	if( sr & STAT_INTR		) printf( " interrupted"		);
	if( sr & STAT_TIMEOUTCLR	) printf( " timeout(noClearance)"	);
	if( sr & STAT_ERRPROTOCOL	) printf( " protocol error"		);
	if( sr & STAT_SEGTOOLARGE	) printf( " image segment too large"	);

	printf( "\n" );
 }


//-----------------------------------------------
// Hack for rewind command

int
T98_leader( sr )
	int			sr;
 {
	return( sr & STAT_LDR );
 }


//* EOF
//********************************************************************************
